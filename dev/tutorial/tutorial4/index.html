<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Stochastic approximation process · ScenTrees.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="ScenTrees.jl logo"/></a><h1>ScenTrees.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorial1/">Introduction</a></li><li><a class="toctext" href="../tutorial2/">Scenario Trees</a></li><li><a class="toctext" href="../tutorial3/">Scenario Lattices</a></li><li><a class="toctext" href="../tutorial31/">Stochastic processes</a></li><li class="current"><a class="toctext" href>Stochastic approximation process</a><ul class="internal"><li><a class="toctext" href="#Tree-Approximation-1">Tree Approximation</a></li><li><a class="toctext" href="#Lattice-Approximation-1">Lattice Approximation</a></li></ul></li><li><a class="toctext" href="../tutorial41/">Kernel Density Estimation</a></li><li><a class="toctext" href="../tutorial5/">Performance of <code>ScenTrees.jl</code></a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorials</li><li><a href>Stochastic approximation process</a></li></ul><a class="edit-page" href="https://github.com/kirui93/ScenTrees.jl/blob/master/docs/src/tutorial/tutorial4.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Stochastic approximation process</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Stochastic-approximation-process-1" href="#Stochastic-approximation-process-1">Stochastic approximation process</a></h1><p>This package follows the stochastic approximation procedure and theory in <a href="https://doi.org/10.1007/s10589-015-9758-0">Pflug and Pichler (2015)</a>. Given a stochastic process, we want to approximate the process using either a scenario tree or a scenario lattice.</p><p>Every stochastic approximation iteration modifies one path within the tree towards the new sequence. In this way the approximating quality of the tree is improved each time a new sample is observed. The tree is not stable in the beginning but with more and more iterations, the scenario tree converges in probability. The resulting tree can be used for decision making process.</p><p>The stochastic approximation process is outlined as follows:</p><ol><li>Decide on the branching structure of the tree/ lattice,</li><li>Start with a tree/lattice (which is more of a qualified guess) with the stated branching structure,</li><li>Generate one sample from a particular known distribution with the same length and dimension as the states of the nodes of the tree/lattice.</li><li>The algorithm finds a sequence of nodes in the tree where the distance between the states of those nodes and the generated sample is minimal. The algorithm then updates the states of those nodes with the values in the generated sample. The states of other nodes remains unchanged.</li><li>At every iteration of the algorithm, the multistage distance is calculated.</li><li>When done with the states of the nodes of the tree, the algorithm calculates the conditional probabilities to reach each node in the tree. At the end, the sum of the conditional probabilities to reach each node of the same parent must add up to 1.</li><li>The algorithm stops when all the number of iterations have been performed.</li></ol><p>The most important function in this approximation process is the function that user wants to approximate. This is the function that generates samples that improves the tree in each iteration. <em>The function must be designed in a way that it doesn&#39;t take any inputs. It must be a hard-coded function in that and the length of an array that it produces must match the number of stages of the tree and the dimension of the states of the tree.</em></p><div class="admonition tip"><div class="admonition-title">Tip</div><div class="admonition-text"><p>The branching structure of the scenario tree and the scenario lattice must start with <code>1</code>. This indicates the root of the tree. It also fix the deterministic state of the tree. The rest of the values in the branching vector of the scenario tree or the scenario lattice generally depends on the user. For example, a binary tree in 4 stages would have a branching structure of <code>[1,2,2,2]</code>.</p></div></div><h2><a class="nav-anchor" id="Tree-Approximation-1" href="#Tree-Approximation-1">Tree Approximation</a></h2><p>In this package, we have the function <code>tree_approximation!(Tree(bstructure, dimension), path, nIterations, p = 2, r = 2)</code> which does the stochastic approximation process for scenario trees. This function takes the following inputs:</p><ul><li>Tree (which takes the branching structure and dimension and inputs)</li><li>Name of the function that generates samples from a stochastic process you want to approximate</li><li>Number of iterations</li><li>Choice <code>d</code> of the norm (Example: <code>max = 0,sum = 1,Euclidean = 2</code>(default))</li><li>Choice <code>r</code> for the multistage distance (<code>r = 2</code>(default))</li></ul><p>Given the above inputs, the function does the stochastic approximation process and returns a valuated scenario tree.</p><div class="admonition info"><div class="admonition-title">Info</div><div class="admonition-text"><p>The user must provide the above inputs to the function. The user also dictates where the tree starts from in the script that generates samples from a stochastic process that the user wants to approximate.</p></div></div><h3><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h3><p>Consider the following. We want to approximate the Gaussian random walk in 4 stages with a tree with a branching structure of <code>1x3x3x3</code> in 1 dimension using the usual Euclidean distance ,<code>p=2</code> and <code>r=2</code> for the multistage distance.</p><pre><code class="language-julia">julia&gt; using ScenTrees
julia&gt; ex2 = Tree([1,3,3,3],1)
julia&gt; sol1 = tree_approximation!(ex2, gaussian_path1D, 100000, 2, 2)
julia&gt; tree_plot(sol1)
julia&gt; savefig(&quot;treeapprox1.png&quot;)</code></pre><p>The function <code>gaussian_path1D()</code> takes no inputs and generates one trajectory of the Gaussian random walk in 4 stages. For each iteration of the process, this process function generates a trajectory that will help improve the states of the nodes in the scenario tree.</p><pre><code class="language-julia">julia&gt; gaussian_path1D()   # 4 stages, 1 dimension
[0.0, 1.49765, -0.17537, -1.2982]</code></pre><p>The output for the above approximation, shown below, is a scenario tree that is stable and represents the stochastic process in the best possible way.</p><p><img src="../../assets/treeapprox1.png" alt="Example of a valuated tree in 1D"/></p><p>We can also approximate a stochastic process in two dimension. Consider the Gaussian random walk in 2D. Our function <code>gaussian_path2D</code> can generate samples from the Gaussian random walk in 2 dimension, for example as follows:</p><pre><code class="language-julia">julia&gt; gaussian_path2D() # 4 stages, 2 dimension
[1.0000, 0.76636, 3.65296, 5.1779; 0.0000, -0.44216, -0.14275, -0.42350]</code></pre><p>We can therefore approximate a scenario tree in 2 dimension as follows:</p><pre><code class="language-julia">julia&gt; ex3 = Tree([1,3,3,3],2);
julia&gt; sol2 = tree_pproximation!(ex3, gaussian_path2D, 1000000, 2, 2);
julia&gt; trees = part_tree(sol2)
julia&gt; tree_plot(trees[1])
julia&gt; savefig(&quot;trees1.png&quot;)
julia&gt; tree_plot(trees[2])
julia&gt; savefig(&quot;trees2.png&quot;)</code></pre><p>Each of these scenario trees have a multistage distance of <code>0.25142</code> from the original stochastic process.</p><table><tr><th style="text-align: center"><a href="../../assets/trees1.png"><img src="../../assets/trees1.png" alt="Tree for state 1"/></a></th><th style="text-align: center"><a href="../../assets/trees2.png"><img src="../../assets/trees2.png" alt="Tree for state 2"/></a></th></tr><tr><td style="text-align: center">Tree for state 1</td><td style="text-align: center">Tree for state 2</td></tr></table><h2><a class="nav-anchor" id="Lattice-Approximation-1" href="#Lattice-Approximation-1">Lattice Approximation</a></h2><p>As mentioned before, some of the process that you may want to approximate are Markovian data processes. These processes can only be approximated by a scenario lattice. All the nodes in the same stage in a lattice have the same children nodes.</p><p>To approximate a Markovian data process, we use the function <code>lattice_approximation(bstructure, path, nIterations, r = 2, dim = 1)</code>.</p><p>The following are the description of the inputs of the function:</p><ul><li>Branching structure of the scenario lattice,</li><li>Function that generates samples from the stochastic process you want to approximate and,</li><li>Number of iterations to be performed, and,</li><li>Multistage parameter, <code>r</code> ( default, <code>r = 2</code>)</li><li>Dimension which you are working on, <code>dim</code> (default, <code>dim = 1</code>)</li></ul><p>Lattice Approximation follows the same stochastic approximation process as for the scenario tree. The only difference is that, in each stage of a lattice, we find the closest lattice entry and use the sample generated to improve it. At the beginning, the lattice is not stable but with more and more iterations, the scenario lattice converges in probability and the resulting lattice can then be used for decision making process.</p><p>All the probabilities in each stage of the lattice must sum up to 1.</p><h3><a class="nav-anchor" id="Example-2" href="#Example-2">Example</a></h3><p>Consider the following example. We want to approximate a Gaussian random walk of 4 stages in one dimension with a scenario lattice with the branching structure of <code>1x3x4x5</code> and 1,000,000 iterations.</p><pre><code class="language-julia">julia&gt; sol4 = lattice_approximation([1,3,4,5], gaussian_path1D, 1000000, 2, 1);</code></pre><p>The result of the above approximation is a scenario lattice which represents the stochastic process in the best way. The distance between the scenario tree and the original process is <code>0.8388</code>. This scenario lattice can thus be used for decision making process under uncertainty.</p><p>Notice that the sum of probabilities of the scenario lattice at each stage is equal to 1.</p><pre><code class="language-julia">julia&gt; sum.(sol4.probability)
[1.0, 1.0, 0.999999999, 1.0]</code></pre><div class="admonition info"><div class="admonition-title">Info</div><div class="admonition-text"><p>To visualize a scenario lattice, we use the <code>plot_lattice</code> function.</p></div></div><pre><code class="language-julia">julia&gt; plot_lattice(sol4)
julia&gt; savefig(&quot;LatticeApprox.png&quot;)</code></pre><p>The above approximation gives the following output:</p><p><img src="../../assets/LatticeApprox.png" alt="Example of an approximated lattice"/></p><p>You can see that in the scenario lattice, we have many possibilities than in a scenario tree. This shows generally that scenario lattices with half the number of nodes of a scenario tree have more number of scenarios or trajectories. A scenario lattice does not allow to trace back the history of a given scenario based on its ending node as there are many possible paths at that node. This is the main reason why we consider scenario lattices for Markovian processes</p><footer><hr/><a class="previous" href="../tutorial31/"><span class="direction">Previous</span><span class="title">Stochastic processes</span></a><a class="next" href="../tutorial41/"><span class="direction">Next</span><span class="title">Kernel Density Estimation</span></a></footer></article></body></html>
