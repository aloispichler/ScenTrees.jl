        - using Statistics
        - using LinearAlgebra
        - using PyPlot
        - 
        - mutable struct Lattice
        -     name::String
        -     state::Array{Array{Float64,2},1}
        -     probability::Array{Array{Float64,2},1}
        1     Lattice(name::String,state::Array{Array{Float64,2},1},probability::Array{Array{Float64,2},1}) = new(name,state,probability)
        - end
        - 
        - """
        - 	LatticeApproximation()
        - 
        - Returns a valuated scanario lattice. It takes as inputs a vector of branching structure and the sample size.
        - 
        - """
        - 
        - 
        - function LatticeApproximation(states::Array{Int64,1},nScenarios::Int64)
        1     WassersteinDistance = 0.0
        -     rWasserstein = 2
        1     lns = length(states)
        1     LatState = [zeros(states[j],1) for j = 1:lns]                                             # States of the lattice at each time t
        1     LatProb = vcat([zeros(states[1],1)],[zeros(states[j-1],states[j]) for j = 2:lns])          # Probabilities of the lattice at each time t
        - 
        -     #Stochastic approximation
        2     for n = 1:nScenarios
        -         #Z = 300 .+ 50 * vcat(0.0,cumsum(randn(lns-1,1),dims = 1))
   500000         Z = vcat(0.0,cumsum(randn(lns-1,1),dims = 1))                                           #draw a new sample Gaussian path
        -         idtm1 = 1
        -         dist = 0.0
  1000000         for t = 1:length(states)                                                                #walk along the gradient
  2500000             sumLat = sum(LatProb[t],dims = 2)
  2500000             sqStates = 1.3 * sqrt(n) / states[t]
  2500000             tmp = Int64[id for (id,ls) in enumerate(sumLat) if ls < sqStates]
  2500010             LatState[t][tmp] .= Z[t]                                                            #corrective action to include lost nodes
  7500000             mindist,indx = findmin(vec(abs.(LatState[t] .- Z[t])))                              #find the closest lattice entry
  2500000             dist = dist + mindist^2                                                             #Euclidean distance for the paths
  2500000             LatProb[t][idtm1,indx] = LatProb[t][idtm1,indx] .+ 1.0                              #increase the probability
        -             idtm1 = indx
  4500000             LatState[t][indx] = LatState[t][indx] - 2 / (3000 + n)^0.75 *rWasserstein * mindist^(rWasserstein-1) * (LatState[t][indx] - Z[t])
        -         end
   500000         dist = dist^(1/2)
   999999         WassersteinDistance = (WassersteinDistance*(n-1) + dist^rWasserstein)/n
        -     end
        2     LatProb = LatProb ./ nScenarios                                               #scale the probabilities to 1.0
        1     return Lattice("Lattice Approximation of $states, \n distance=$(round(WassersteinDistance^(1/rWasserstein),digits = 4)) at $(nScenarios) scenarios",LatState,LatProb)
        - end
        - 
        - function PlotLattice(lt::Lattice)
        -     pt = subplot2grid((1,length(lt.state)),(0,0),colspan = length(lt.state))
        -     pt.spines["top"].set_visible(false)                                           #remove the box at the top
        -     pt.spines["right"].set_visible(false)                                         #remove the box at the right
        -     for t = 2:length(lt.state)
        -         for i=1:length(lt.state[t-1])
        -             for j=1:length(lt.state[t])
        -                 pt.plot([t-2,t-1],[lt.state[t-1][i],lt.state[t][j]])
        -             end
        -         end
        -     end
        -     xlabel("stage")
        -     ylabel("states")
        -     xticks(0:length(lt.state)-1)
        - end
        - 
